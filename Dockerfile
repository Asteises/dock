# определяем базовый образ
FROM amazoncorretto:11-alpine-jdk
# <amazoncorretto> — имя базового образа
# <11-alpine-jdk> — необязательный параметр, указывает конкретную версию образа

# Чтобы к приложению можно было подключиться для отладки, необходимо запустить его со следующими параметрами:
# -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:[номер порта для отладки]
ENV JAVA_TOOL_OPTIONS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8081
# transport=dt_socket — способ подключения к JVM, подключение будет происходить с помощью сокетов
# server=y — к приложению будут подключаться для отладки, а не наоборот
# suspend=n — JVM будет ждать, пока отладчик подключится для начала выполнения команд. Иначе выполнение начинается сразу же
# address=*:[номер порта] — номер порта для подключения. Обычно берётся +1 от порта, который используется для самого приложения

# задаем переменную окружения
ARG JAR_FILE=target/*.jar

# копируем файлы и директории из указанной локальной директории в директорию контейнера
COPY ${JAR_FILE} app.jar
# COPY ["<файл/директория>", "<путь-внутри-контейнера>"]

# ENTRYPOINT - консольная команда, которая выполнится внутри контейнера после его запуска ENTRYPOINT ["executable", "param1", "param2"]
ENTRYPOINT ["java","-jar","/app.jar"]
# В данном случае после запуска контейнера выполнится команда java -jar /app.jar, которая запустит Java-приложение

#---------------------------------------------
# Собираем образ: docker build -t dock_image .
# build — команда сборки образа по инструкциям из Dockerfile
# -t <имя образа> — ключ, который позволяет задать имя образу (в нашем примере это dock_image)
# . — точка в конце команды, путь до Dockerfile, на основе которого производится сборка. Обычно Dockerfile располагают непосредственно в директории для сборки, из которой и запускается docker build, — поэтому указывается только точка

#---------------------------------------------
# Посмотреть какие образы существуют на данном ПК: docker image ls

# Удалить лишние образы: docker image rm <IMAGE_ID>
# где IMAGE_ID это идентификатор образа который нужно подставить: docker image rm feb5d9fea6a5

#---------------------------------------------
# Чтобы запустить контейнер: docker run --name dock_container -p 8080:8080 dock_image
# run — команда запуска нового контейнера
# --name <имя контейнера> — ключ, который позволяет задать имя контейнеру. Если параметр не указан, Docker сгенерирует его самостоятельно
# -p 8080:8080 — публичный порт контейнера. Левая часть — его внешний порт, правая — порт, на который будет перенаправлен запрос внутри приложения
# dock_image — образ, из которого будет запущен контейнер

#---------------------------------------------
# таблица со списком запущенных контейнеров: docker container ls

#---------------------------------------------
# переименовать контейнер можно командой: docker container rename CONTAINER <NEW_NAME>

#---------------------------------------------
# остановить запущенный контейнер через терминал: docker container stop <CONTAINER ID>

# контейнер можно запустить: docker container start <CONTAINER ID>

#---------------------------------------------
# Список всех команд для работы с контейнером: docker container

#---------------------------------------------
# Версию Docker можно узнать: $ docker --version

#---------------------------------------------
# авторизация на dockerhub: docker login -u <username>

# запушить на dockerhub: docker push <username>/<imagename>:<tag>

# запулить на ПК: docker pull <imagename>

#---------------------------------------------
# запустить командную строку: docker exec -it dock_container /bin/sh

# exec — команда Docker, которая позволяет выполнять команды в запущенном контейнере
# -it — параметры, отвечающие за интерактивный режим, — без них контейнер не будет ждать от вас команд и не будет выводить ответ
# dock_container — имя контейнера, в котором необходимо выполнить команду
# /bin/sh — запуск командной строки
# exit - чтобы выйти

# вывести содержимое текущей директории: ls
# вывести содержимое директории driver, которая вложена в директорию proc в текущей директории: ls proc/driver

# узнать ключи конкретной команды: <консольная_команда> --help

# переход в директорию: cd путь_до_папки
# возврат в корневую директорию: cd /
# возврат в каталог на уровень выше: cd ../

# создать новый файл answer.txt: touch answer.txt
# создать сразу два новых файла — pom.xml и application.properties: touch pom.xml application.properties
# создать новый файл answer.txt в папке new_folder: touch new_folder/answer.txt

# создать папку very_important_folder в той директории, откуда выполнена команда: mkdir very_important_folder
# создать папку temp в каталоге /var/log: mkdir /var/log/temp

# удалить файл super_file.txt из папки file_folder: rm file_folder/super_file_1.txt
# создать файлы, перейти в их каталог и затем удалить: touch file_folder/a.txt file_folder/b.txt
# ls file_folder/
# rm a.txt b.txt

# аналогично можно удалить файлы и без перехода в подкаталог: rm file_folder/a.txt file_folder/b.txt
# удалить папку file_folder/ со всем содержимым: rm -r file_folder/
# можно не указывать / на конце: rm -r file_folder

# скопировать файл logs.txt и назвать новый файл double_logs.txt
# оба файла находятся в текущей папке: cp logs.txt double_logs.txt

# указать путь к исходному файлу logs.txt
# дать копии имя double_logs.txt
# сохранить копию в текущей папке (не нужно указывать путь): cp ../logs/logs.txt double_logs.txt

# скопировать директорию docs под исходным именем в папку Documents: cp -r ../docs/ ../Documents/

# перенести card.txt из текущей директории в корневую: mv card.txt /

# перенести card.txt, указав абсолютный путь: mv card.txt /home/logs/2020/

# перенести card.txt, указав полный путь до переносимого файла: mv home/logs/2021/card.txt /home/logs/2020/

# переименовать файл my_app.ssh в you_app.ssh: mv my_app.ssh you_app.ssh

# перенести файл card.txt и переименовать его в map.txt: mv /home/logs/2020/card.txt /home/logs/2020/map.txt

# создать текстовый файл secret.txt и записать в него строку "Я отличный программист": echo "Я отличный программист" > secret.txt

# абсолютный путь: echo "Я отличный программист" > /secrets/secret.txt

# относительный путь: echo "готовность_к_обучению: 100.00" > ../settings/my_settings.txt

# вывести на экран содержимое текстового файла: cat secrets.txt

# добавить текст и создать файлы: echo "Три" > 3.txt echo "Два" > 2.txt echo "Раз" > 1.txt

# вывести три файла в указанном порядке: cat 1.txt 2.txt 3.txt Раз Два Три

# вывести содержимое файла a.txt в окно терминала: cat a.txt AAA
# в файле a.txt хранится строка AAA

# вывести содержимое файла b.txt в окно терминала: cat b.txt BBB
# в файле b.txt хранится строка BBB

# заменить содержимое файла b.txt на содержимое файла a.txt: cat a.txt > b.txt

# данные в файле b.txt перезаписаны, содержимое файлов идентично: cat b.txt AAA  cat a.txt AAA

# снова сохранить строку ВВВ в b.txt: echo "BBB" > b.txt

# скопировать содержимое a.txt в b.txt, не перезаписывая данные: cat a.txt >> b.txt

# вывести b.txt: cat b.txt
# BBB
# AAA

# соединить содержимое 1.txt и 3.txt и сохранить в конец b.txt: cat 1.txt 3.txt >> b.txt cat b.txt
# BBB
# AAA
# Раз
# Три

# соединить содержимое 2.txt и 1.txt и сохранить в b.txt, перезаписав данные: cat 2.txt 1.txt > b.txt cat b.txt
# Два
# Раз

#---------------------------------------------
# установить редактор nano: apk add nano

# поиск по файлу: grep [Ключ(и)] PATTERN [Адрес]
# Вместо PATTERN нужно подставить искомую строку или слово. Для одного слова кавычки можно не использовать. Если слов несколько, их обязательно нужно взять в кавычки. Например: "system error"
# Вместо [Адрес] нужно поставить путь до файла
# [Ключ(и)] — это специальные символы, которые влияют на отображение и поиск информации. Например, показывают, что нужно проигнорировать регистр при поиске

# к примеру вернуть все строки из файла: grep INFO logs.txt

# сохранит все строки, где есть слово ERROR в файл errors.txt: grep ERROR /test1/test2/test_Logs/Log1.txt > errors.txt

# команда для просмотра последних строк файла, ключ -f для беспрерывного просмотра: tail -f logs.txt

#---------------------------------------------
# Посмотреть список запущенных процессов: ps

# отображает данные по процессам в реальном времени: top

# Остановить нежелательный процесс: kill [ключ] [PID]

# ключ для сигнала SIGKILL: -9

